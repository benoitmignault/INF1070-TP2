#!/bin/bash

# Elle sera utilisé à chaque fois qu'on aura un message d'erreur
function message_erreur_exit(){

    echo "$1" >&2
    exit $2
}

# 






# Début de l'exécution du script

# Si le nombre d'arguments est en bas de 2 ou supérieur à 5, Exit 1
if [ $# -lt 2 ] || [ $# -gt 5 ]; then

    message_erreur_exit "Veuiller fournir entre 2 et 5 arguments !" 1
fi

# La liste des options valides
choix_option_valid='^-[fnc]$'
choix_option_mauvais='^-.*'

# Validation sur un nombre positif
nb_valide='^[0-9]+$'


# Les variables de contrôles contre les erreurs
option_fichier=false    
option_nbligne=false
option_charHex=false 

# Les variables utilisables 
nom_fichier=""  # Nom du fichier
nb_lignes=0     # Par défaut à 0 

# Les variables arguments pour la gestion des situations possible
argument_actuel=""
argument_precedent=""

# Décision d'utiliser un forEach, finalement
for argument in "$@"; do

    # On associ l'ancien argument à la variable
    argument_precedent="$argument_actuel"
    argument_actuel="$argument"

    # Maintenant, on doit trouver notre option qui a été validée
    case "$argument_actuel" in
        "-f")
            # On doit valide que nous n'avons pas déjà saisie l'optionune option
            if [ "$option_fichier" = true ]; then

                message_erreur_exit "Vous ne pouvez pas saisir une option déjà utilisée « $option_actuelle »..." 4
            fi                
            ;;
        "-n")
            # On doit valide que nous n'avons pas déjà saisie une option
            if [ "$option_nbligne" = true ]; then  

                message_erreur_exit "Vous ne pouvez pas saisir une option déjà utilisée « $option_actuelle »..." 4
            fi                
            ;;
        "-c")
            # On doit valide que nous n'avons pas déjà saisie une option
            if [ "$option_charHex" = true ]; then
                
                message_erreur_exit "Vous ne pouvez pas saisir une option déjà utilisée « $option_actuelle »..." 4
            fi
            ;;
        *)
            ;;    
    esac    
done


# Maintenant, que nous avons itéré sur tous les arguments, finalisation des scénarios d'erreur, avant de faire la commande
if [ "$option_nbligne" = true ]; then

    if [ "$nb_lignes" -eq 0 ]; then        
        message_erreur_exit "Vous avez omis de saisir le nombre de lignes vue l'utilisation de l'option -n..." 3
    fi

    # Nous avons pas reçu l'option -f
    if [ "$option_fichier" = false ]; then
        message_erreur_exit "L'option -f a été omis..." 2
    fi

    # Le nom du fichier est absent
    if [ ! -n "$nom_fichier" ]; then
        message_erreur_exit "L'option -f avec son nom de fichier a été omis..." 2
    fi   
else
    # Comme l'option du nombre de ligne n'a pas été choisie, on va attribuer une valeure par défaut.
    nb_lignes=10
fi

# subtitution de commande qui l'a donner à la variable pour l'executer via la commande echo
commande=$(grep 'href="file://' "$nom_fichier" | awk -F'"' '{print $2}' | sed 's/file:\/\///g' | sort -r | head -n "$nb_lignes")

if [ -n "$commande" ] && [ "$option_charHex" = true ]; then
    # Conversion des % pour \x pour avoir vraiment des caractères hexa. 
    echo "$commande" | sed 's/%/\\x/g' | xargs -0 printf
else
    echo "$commande"
fi    
